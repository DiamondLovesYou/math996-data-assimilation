
#[macro_use]
extern crate ndarray as nd;
extern crate linxal;
extern crate rand;
extern crate num_traits;

use rand::Rng;

pub mod utils;
pub mod variational;
pub mod kalman;

/// In the example programs provided in Data Assimilation:
/// A Mathematical Introduction, the algorithm assumes the
/// number of steps is known up front. It's possible to move
/// to a code that doesn't make this assumption, but for
/// simplicity I'm ignoring this. I'll eventually get to this.
///
/// I want to have a generic trait to allow users
/// to ask for an arbitrary number of extra predictor steps on
/// every loop.
///
/// Additionally, I've excluded any consideration of errors, ie
/// those generated by LAPACK under the hood. TODO.
///
/// ndarray doesn't expose interfaces for using permutation
/// matrices (LAPACK has the capability, of course). XXX
///
/// Ugh. Upon more thought, ndarray needs work (ie general
/// gemm panics if dims are wrong. the function in question
/// should instead return a Result). XXX


pub trait Workspace<I>
  where I: Initializer,
{
  fn alloc(i: I, rand: &mut Rng, total_steps: u64) -> Self;
}
pub trait Initializer { }
pub trait State<'a, WS> {
  fn current(ws: &'a WS) -> Self;
}

pub trait Algorithm {
  type Init: Initializer;
  type WS: Workspace<Self::Init>;
  type Model;

  fn init(i: &Self::Init,
          rand: &mut Rng,
          model: &mut Self::Model,
          steps: u64) -> Self;

  /// This function shall not allocate.
  fn next_step(&self,
               current_step: u64,
               total_steps: u64,
               rand: &mut Rng,
               workspace: &mut Self::WS,
               model: &mut Self::Model)
               -> Result<(), ()>;
}
